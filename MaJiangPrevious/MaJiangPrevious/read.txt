1 胡牌模式(包含了清一色，混一色等特殊牌型)分：
	14张：
		[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[2]]
		[[1, 1, 1], [1, 1, 1], [1, 1, 1], [3], [2]]
		[[1, 1, 1], [1, 1, 1], [3], [3], [2]]
		[[1,1,1],[3],[3],[3],[2]]
		[[3],[3],[3],[3],[2]]

	11张：
		[[1,1,1],[1,1,1],[1,1,1],[2]]
		[[1,1,1],[1,1,1],[3],[2]]
		[[1,1,1],[3],[3],[2]]
		[[3],[3],[3],[2]]

	8张：
		[[1,1,1],[1,1,1],[2]]
		[[1,1,1],[3],[2]]
		[[3],[3],[2]]

	5张：
		[[1,1,1],[2]]
		[[3],[2]]

	2张：
		[[2]]

	七对子：
		[[2], [2], [2], [2], [2], [2], [2]]

2 碰，吃，杠等基础操作，选择贪心策略(只要玩家手里存在，就给提示)，这里不做处理

3 对每种模式，做一个全排列并去掉重复的，得到所有模式
	，比如
	[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[2]]
	全排列为
	[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[2]]
	[[1,1,1],[1,1,1],[1,1,1],[2],[1,1,1]]
	[[1,1,1],[1,1,1],[2],[1,1,1],[1,1,1]]
	[[1,1,1],[2],[1,1,1],[1,1,1],[1,1,1]]
	[[2]，[1,1,1],[1,1,1],[1,1,1],[1,1,1]]
	，以及
	[[2], [2], [2], [2], [2], [2], [2]]
	全排列为
	[[2], [2], [2], [2], [2], [2], [2]]

4 接下来每种模式再扩展新的模式
	，比如 size = 4
	索引		0		1		2	  3
	数据	[[1,1,1],[1,1,1],[1,1,1],[2]]
	for (int i = 0; i < size; ++i)
	{
		for (int j = i + 1; j < size; ++j)
		{
			i和j的数据做一个如下计算
			（假定i=0，j=1，则数据为
			di = [1,1,1], dj = [1,1,1]
			di的sizei=3
			dj的sizej=3）
			a 创建一个数组 t = [sizej个0，di，sizej个0]
			  此时 t = [0 0 0 1 1 1 0 0 0]
			b 将dj与t数据向量求和，然后移动1位。类似做个卷积，即
				dj =[1,1,1]
				t = [0 0 0 1 1 1 0 0 0]
				dj每次计算都向右边移动1位，移动 sizei + sizej 次，总共计算sizei + sizej + 1次
				(移动第一次，为
					dj =  [1,1,1]
					t = [1 1 1 1 1 1 0 0 0]
				)

			c 2步奏计算一次得到一个模式
				第一次的计算得到 t = [1 1 1 1 1 1] (这里需要去除为0的数据)
				模式为 [[1 1 1 1 1 1],[1,1,1],[1,1,1],[2]]

			d 3步计算得到的模式，递归计算得到该模式的所有模式
				
		}
	}

5 对4做一些缓存优化(针对递归)，搜集得到所有的模式

6 每一种模式都是一种胡牌的类别，最后对模式进行分析
	// ret
	//   3bit  0: 三个一样的 个数(0～4)
	//   3bit  3: 顺子的个数(0～4)
	//   4bit  6: 将的个数(1～13)
	//   4bit 10: 保留的位置１(0～13)
	//   4bit 14: 保留的位置２(0～13)
	//   4bit 18: 保留的位置３(0～13)
	//   4bit 22: 保留的位置４(0～13)
	//   1bit 26: 胡牌的类型
	//	 1bit 27: 胡牌的类型
	//   1bit 28: 胡牌的类型
	//   1bit 29: 胡牌的类型
	//   1bit 30: 胡牌的类型
	a 遍历的方式处理
	b 现确定将
	c 顺子优先或3个优先进行处理
	d 计算得到 顺子的个数，3个的个数
	e 通过分析确定胡牌类型(七小对，清一色等)

7 输出最后的结果对 (胡牌的模式以及对应胡牌的牌型)